// === ADAS + Manual Driving Simulation with ESP32 & Blynk IoT + DIRS ===
// Components: 3 HC-SR04, 5 Direction LEDs, Brake/Accel LEDs, Blynk App (joystick, buttons, speedometer, DIRS score)
#define BLYNK_TEMPLATE_ID "TMPL36ebGfkpL"
#define BLYNK_TEMPLATE_NAME "ADAS"
#include <WiFi.h>
#include <BlynkSimpleEsp32.h>

// === WiFi & Blynk Auth ===
char auth[] = "KO6LWncMF-DzIwOQydZltYr_RKO7sTh6";
char ssid[] = "iotresearchlab";
char pass[] = "iotlab2023";

// === Blynk Virtual Pins ===
#define VPIN_JOYSTICK V0
#define VPIN_ACCEL_BUTTON V1
#define VPIN_BRAKE_BUTTON V2
#define VPIN_SPEEDOMETER V3
#define VPIN_MODE_MANUAL V4
#define VPIN_MODE_ADAS V5
#define VPIN_IGNITION V6
#define VPIN_BRAKE_LED V7
#define VPIN_ACCEL_LED V8
#define VPIN_DIRS_SWITCH V9
#define VPIN_DIRS_SCORE V10

// === HC-SR04 Pins (ESP32 GPIO Numbers) ===
#define TRIG_CENTER 23
#define ECHO_CENTER 22
#define TRIG_LEFT 21
#define ECHO_LEFT 19
#define TRIG_RIGHT 18
#define ECHO_RIGHT 5

// === Direction LEDs ===
#define LED_WEST 15
#define LED_NORTHWEST 2
#define LED_NORTH 4
#define LED_NORTHEAST 16
#define LED_EAST 17

// === Brake & Acceleration LEDs ===
#define LED_BRAKE 13
#define LED_ACCEL 12

// === Runtime Variables ===
int joyX = 128, joyY = 128;
bool accelPressed = false;
bool brakePressed = false;
bool ignitionOn = false;
bool adasMode = false;
bool dirsOn = false;
unsigned long lastSteerTime = 0;
unsigned long lastSpeedUpdate = 0;
int speed = 0;
int dirsScore = 100;

void setup() {
  Serial.begin(115200);
  Blynk.begin(auth, ssid, pass);

  pinMode(TRIG_CENTER, OUTPUT); pinMode(ECHO_CENTER, INPUT);
  pinMode(TRIG_LEFT, OUTPUT); pinMode(ECHO_LEFT, INPUT);
  pinMode(TRIG_RIGHT, OUTPUT); pinMode(ECHO_RIGHT, INPUT);

  pinMode(LED_WEST, OUTPUT); pinMode(LED_NORTHWEST, OUTPUT);
  pinMode(LED_NORTH, OUTPUT); pinMode(LED_NORTHEAST, OUTPUT); pinMode(LED_EAST, OUTPUT);
  pinMode(LED_BRAKE, OUTPUT); pinMode(LED_ACCEL, OUTPUT);

  // Ensure initial state is Manual mode
  adasMode = false;
  dirsScore = 100;
  Blynk.virtualWrite(VPIN_MODE_MANUAL, 1);
  Blynk.virtualWrite(VPIN_MODE_ADAS, 0);
  Blynk.virtualWrite(VPIN_DIRS_SCORE, dirsScore);
}

void loop() {
  Blynk.run();
  if (!ignitionOn) {
    resetAll();
    return;
  }

  if (!adasMode) {
    checkManualDriving();
  } else {
    checkADASDriving();
  }
  updateSpeed();

  // ADAS auto activation
  if (!adasMode && ((millis() - lastSteerTime > 4000) || dirsScore < 50)) {
    adasMode = true;
    Blynk.virtualWrite(VPIN_MODE_ADAS, 1);
    Blynk.virtualWrite(VPIN_MODE_MANUAL, 0);
  }
}

// === Blynk Handlers ===
BLYNK_WRITE(VPIN_JOYSTICK) {
  joyX = param[0].asInt();
  joyY = param[1].asInt();
  lastSteerTime = millis();
  if (!adasMode) {
    updateDirectionLEDs();
  }
}

BLYNK_WRITE(VPIN_ACCEL_BUTTON) {
  if (param.asInt() == 1) {
    accelPressed = true;
    brakePressed = false;
  } else {
    accelPressed = false;
  }
}

BLYNK_WRITE(VPIN_BRAKE_BUTTON) {
  if (param.asInt() == 1) {
    brakePressed = true;
    accelPressed = false;
  } else {
    brakePressed = false;
  }
}

BLYNK_WRITE(VPIN_MODE_MANUAL) {
  if (!ignitionOn) return;
  if (param.asInt()) {
    adasMode = false;
    Blynk.virtualWrite(VPIN_MODE_ADAS, 0);
  }
}

BLYNK_WRITE(VPIN_MODE_ADAS) {
  if (!ignitionOn) return;
  if (param.asInt()) {
    adasMode = true;
    Blynk.virtualWrite(VPIN_MODE_MANUAL, 0);
  }
}

BLYNK_WRITE(VPIN_IGNITION) {
  ignitionOn = param.asInt();
  if (ignitionOn) {
    adasMode = false;
    Blynk.virtualWrite(VPIN_MODE_MANUAL, 1);
    Blynk.virtualWrite(VPIN_MODE_ADAS, 0);
  } else {
    resetAll();
  }
}

BLYNK_WRITE(VPIN_DIRS_SWITCH) {
  dirsOn = param.asInt();
}

void updateDirectionLEDs() {
  digitalWrite(LED_WEST, LOW);
  digitalWrite(LED_NORTHWEST, LOW);
  digitalWrite(LED_NORTH, LOW);
  digitalWrite(LED_NORTHEAST, LOW);
  digitalWrite(LED_EAST, LOW);

  if (joyX < 50) digitalWrite(LED_WEST, HIGH);
  else if (joyX < 100) digitalWrite(LED_NORTHWEST, HIGH);
  else if (joyX < 160) digitalWrite(LED_NORTH, HIGH);
  else if (joyX < 210) digitalWrite(LED_NORTHEAST, HIGH);
  else digitalWrite(LED_EAST, HIGH);
}

void updateSpeed() {
  if (millis() - lastSpeedUpdate < 200) return;
  lastSpeedUpdate = millis();

  int dist = getDistance(TRIG_CENTER, ECHO_CENTER);
  bool obstacleClose = (dist > 0 && dist < 6);
  bool brakeNow = brakePressed || obstacleClose;

  if (brakeNow) {
    accelPressed = false;
    speed -= (speed <= 30 ? 20 : 10);
    digitalWrite(LED_BRAKE, HIGH);
    digitalWrite(LED_ACCEL, LOW);
    Blynk.virtualWrite(VPIN_BRAKE_LED, 255);
    Blynk.virtualWrite(VPIN_ACCEL_LED, 0);
  } else if (accelPressed) {
    brakePressed = false;
    if (adasMode && speed >= 80) {
      accelPressed = false;
    } else {
      if (speed < 30) speed += 10;
      else if (speed < 60) speed += 5;
      else if (speed < 90) speed += 3;
      else if (speed < 120) speed += 1;
    }
    digitalWrite(LED_ACCEL, accelPressed);
    digitalWrite(LED_BRAKE, LOW);
    Blynk.virtualWrite(VPIN_ACCEL_LED, accelPressed ? 255 : 0);
    Blynk.virtualWrite(VPIN_BRAKE_LED, 0);
  } else {
    if (speed > 0) speed -= (speed <= 30 ? 3 : 2);
    digitalWrite(LED_ACCEL, LOW);
    digitalWrite(LED_BRAKE, LOW);
    Blynk.virtualWrite(VPIN_ACCEL_LED, 0);
    Blynk.virtualWrite(VPIN_BRAKE_LED, 0);
  }
  speed = constrain(speed, 0, 120);
  Blynk.virtualWrite(VPIN_SPEEDOMETER, speed);
  Blynk.virtualWrite(VPIN_DIRS_SCORE, dirsScore);
}

void checkADASDriving() {
  int left = getDistance(TRIG_LEFT, ECHO_LEFT);
  int center = getDistance(TRIG_CENTER, ECHO_CENTER);
  int right = getDistance(TRIG_RIGHT, ECHO_RIGHT);

  digitalWrite(LED_WEST, LOW);
  digitalWrite(LED_NORTHWEST, LOW);
  digitalWrite(LED_NORTH, LOW);
  digitalWrite(LED_NORTHEAST, LOW);
  digitalWrite(LED_EAST, LOW);

  if (center > 0 && center < 6) {
    brakePressed = true;
    accelPressed = false;
    digitalWrite(LED_BRAKE, HIGH);
    digitalWrite(LED_NORTHEAST, HIGH);
  } else if (center >= 6 && center <= 20) {
    brakePressed = false;
    accelPressed = true;
    digitalWrite(LED_NORTHEAST, HIGH);
  } else if (left < 20 && left > 0) {
    digitalWrite(LED_EAST, HIGH);
  } else if (right < 20 && right > 0) {
    digitalWrite(LED_WEST, HIGH);
  } else {
    brakePressed = false;
    accelPressed = true;
    digitalWrite(LED_NORTH, HIGH);
  }
}

void checkManualDriving() {
  updateDirectionLEDs();

  int left = getDistance(TRIG_LEFT, ECHO_LEFT);
  int center = getDistance(TRIG_CENTER, ECHO_CENTER);
  int right = getDistance(TRIG_RIGHT, ECHO_RIGHT);

  if (center > 0 && center < 6) {
    brakePressed = true;
    accelPressed = false;
  }

  if (dirsOn) {
    bool wrongDir = false;
    if (left > 0 && left < 20 && joyX < 50) wrongDir = true;
    else if (right > 0 && right < 20 && joyX > 210) wrongDir = true;
    else if (center > 0 && center < 20 && joyX >= 100 && joyX <= 160) wrongDir = true;

    if (wrongDir && dirsScore > 0) dirsScore -= (speed >= 60 ? 3 : 1);
    else if (!wrongDir && dirsScore < 100) dirsScore++;
    dirsScore = constrain(dirsScore, 0, 100);
  }
}

int getDistance(int trig, int echo) {
  digitalWrite(trig, LOW); delayMicroseconds(2);
  digitalWrite(trig, HIGH); delayMicroseconds(10);
  digitalWrite(trig, LOW);
  long duration = pulseIn(echo, HIGH, 20000);
  if (duration == 0) return -1;
  return duration * 0.034 / 2;
}

void resetAll() {
  speed = 0;
  dirsScore = 100;
  accelPressed = brakePressed = false;
  adasMode = false;
  digitalWrite(LED_WEST, LOW);
  digitalWrite(LED_NORTHWEST, LOW);
  digitalWrite(LED_NORTH, LOW);
  digitalWrite(LED_NORTHEAST, LOW);
  digitalWrite(LED_EAST, LOW);
  digitalWrite(LED_BRAKE, LOW);
  digitalWrite(LED_ACCEL, LOW);
  Blynk.virtualWrite(VPIN_SPEEDOMETER, 0);
  Blynk.virtualWrite(VPIN_ACCEL_LED, 0);
  Blynk.virtualWrite(VPIN_BRAKE_LED, 0);
  Blynk.virtualWrite(VPIN_MODE_MANUAL, 0);
  Blynk.virtualWrite(VPIN_MODE_ADAS, 0);
  Blynk.virtualWrite(VPIN_DIRS_SCORE, dirsScore);
}

